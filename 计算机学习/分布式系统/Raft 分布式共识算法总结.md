## 前言

写过 6.5840，有过丰富的 Raft 实验 debug 经历，但是在面试的过程中问到 raft 的时候，还是会不知道如何开口，因此写一篇总结。

raft 针对的不是单一数值的共识，而是基于一系列日志实现的关于一组数据的共识算法。我们知道希望在分布式系统里面让一组数据在多个节点上达成共识很容易让人不知道从何入手，而 Raft 则将这个问题拆成了三部分：
1. Leader 选举
2. 日志复制
3. 安全性

## Leader 选举

首先是第一条，Leader 选举，为什么需要选举 Leader？可以有多个 Leader 吗？在没有出现网络分区且没有节点发起选举的情况下，我们的 Leader 是唯一的写入节点和同步节点，而其他所有节点都是 follower，当出现**严重**网络分区的时候，其实也不会有大问题，只是写入变成了经典的 CP 模型，无法得到半数的日志复制共识，写入会阻塞无法返回给客户端。

唯一的 Leader 是为了不让多个节点能够进行写入的情况发生，Leader 是唯一的写入节点，其他的 follower 就可以以这一个 Leader 为基准进行数据共识的达成。而如果有两个及以上的 Leader 会出现什么情况？写入就会混乱，我们很难去确定不同 Leader 写入的顺序，以及每个 follower 应该去同步哪一个 Leader 的日志，当然 paxos 可以支持多个 Leader，但是也有活锁问题，所以 paxos 一般还是单 Leader。单 Leader 保证了 Raft 复制数据的时候没有特别复杂的逻辑，整体的架构非常简洁。

Leader 选举主要是发生在某一个 follower 可能因为网络延迟等原因没有及时接收到 Leader 的心跳，他就会发起 Leader 选举，这一步他先变成 candidate，也就是候选者，而对于其他所有节点，接收到请求投票的时候，会按照任期、日志进度等状态进行比对，然后才会选择投票，follower 在对方的日志必须要大于或等于自己的日志状态的前提下（保证 commitIdx 不会丢），总是会向任期更新的节点投票，否则只更新自己的任期，如果不这样做，仅仅依赖于日志或者其他的策略，在 Leader 真正失联的时候，可能没办法及时的选举出一个 Leader。这样一个仅仅一次网络延迟就可能会引发重新选主，因此，我们的分布式共识的数据同步的代价肯定不能太大。如果类似于 Redis 每次主从同步都需要全量同步的话，那么肯定是不合适的。因此，我们便采用了日志作为我们 Raft 达成共识所需要复制的数据单元。

## 日志复制

众所周知，multi-paxos 的实现主要也是对一个日志条目的每个栏目 log slot 进行 basic-paxos 算法从而达成共识，而 Raft 将日志当作了一等公民，选取了日志作为复制的基本单元，整个协议都是围绕日志进行设计的，我觉得原因主要有以下几点：
1. 日志是线性的，并且是一个数组的形式，总体写入的顺序呈时间的先后顺序，天然和一些数据库的写入命令日志的形式相契合，当我们在日志非常长的时候，我们先前大量占比的日志都是极大概率都已经超过了半数的写入（除非网络状态极其糟糕，当然我们一般不考虑），在这种情况下，我们前面的日志，也就是 commitIdx 之前的日志不可能会有任何覆盖和更改了，那么我们在重新选主和同步的时候也根本不需要去同步这些日志了，我们只需要根据实际的情况去处理 commitIdx 之后的日志条目即可，这极大地提高了我们数据复制和达成共识的效率。
2. 日志分为多个条目，在 multi-paxos 算法中可能需要对于每个条目进行一次 basic-paxos 算法，我们可以优化成针对于整个日志条目进行共识，由于每个条目是独立的，所以我们可以批量地而不是一条一条地进行共识达成。
结合以上的优点，我们可以认知到日志复制这个决定能带来很多好处。

## 安全性

安全性也是 Raft 里面非常重要的一部分，他需要保证我们已经提交的日志不能丢，也就是 commitIdx 之前的日志在任何情况下都不能够被覆盖。

我们知道，在同一个任期里面，这个任期的日志被复制到半数以上的节点，那么他就可以视作是安全的，为什么？比如我们当前有一个写入命令已经被复制到半数的节点，那么此时如果有另一个没有复制到这个数据的节点发起了 Leader 选举怎么办？很简单，这个 Candidate 没办法筹集到半数的节点来为他投票，因为投票除了任期更新，还需要满足的是日志复制状态必须要大于等于这个节点。所以说此时并不会被覆盖。

那么当我们在新的任期里面，如果有旧的任期的日志被复制到半数的节点上，可以认为是安全的吗？答案是不可以，我们此时不能够推进 commitIdx，举个例子：
![[Pasted image 20260203221750.png]]当我们的任期为 2 的日志复制到了半数的节点上，此时我们可以注意到 S5 是具有任期为 3 的日志的，那么此时 S5 成为了 Leader 就会覆盖掉这些复制到半数节点的任期为 2 的日志，所以每个任期只能承诺自己当前任期复制到半数节点上的日志是不会丢失的，此时才能够推进 commitIdx。

对于 Raft 新节点加入和旧节点退役现在我还没研究过，暂时先不提。

## 总结

总结一下，paxos 共识算法是针对于某一个值的达成共识，而 raft 相对是维护了一组数据集合的共识，工程完备性更高，paxos 想要真正的用在工程上，还需要进行一系列改进，比如 multi-paxos 也就是进行多次 basic-paxos 算法，实现细节比较抽象，冲突边界也很难确定，而且这样也会带来很多的性能上有所不足，所以还需要进行很多优化操作，相对来讲整个状态机也比较复杂，难以维护，并且实际生产的可用性有待调研；而 Raft 共识算法可以直接用于工程上，更加直观、作用的边界更明确、冲突之类的更可控，直接当作底层的复制状态机即可投入使用。