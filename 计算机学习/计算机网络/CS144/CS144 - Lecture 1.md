# CS144 - Lecture 1

由于没讲义，全看课了，系统性的总结有点难，记一些有趣的东西吧。

---

![QQ_1748236698653](QQ_1748236698653.png)

## 数据链路和网络层的传输

我们可以看见，对于发送方，我们的数据链路层为我们的网络层提供服务，在经过路由的时候，我们的路由的网络层会检查数据报的目的地址，然后根据目的地址决定下一跳的链路是怎么走的！直到到达目的地。而我们是如何决定的？我们的内核会维护一个路由表，它存在于内存之中，我们可以通过检索他来实现快速决定下一跳。而这一点，不仅对于主机，对于路由器也是一样的，路由器中实现了网络层和链路层，需要内存去维护路由表，也就是说，路由器甚至也是一个操作系统！

这里问了 gpt 一些子网的问题，如果国家不同，子网也会不同，经过的网关也会不同，数据的传输会经历什么？我们首先需要知道，网关分为很多层，子网也分为很多层，而计算机就是对应的叶子节点，一个网关对应了多个子节点，下面有子网关以及对应了多台计算机，全世界的计算机就相当于构成了一棵树，我们如果子网不同，在转发过程中就需要先转发到网关，如果依旧不在同一子网，就需要再转发到下一级网关，可以想象成 **小区->城市->省份->国家** 这几层结构。

同时，在看书的时候，我还看见过 ABC 类地址划分，后面又引出了 CIDR 类地址划分，更加灵活，可以按国家，然后国家按地区来分发这些 ip 。

引入另一个概念，**局域网**。

诸如云服务器，都是暴露在公网上面的，都独占一个公网 ip，所以可以直接访问，而比如学校，家庭，都是在局域网里面，通过网关与外部相连，这种情况下，外部请求没办法直接访问局域网，因为 NAT 就是这样，但是通过 NAT 我们可以直接访问外部，并且可以接受对方的返回信息，这里是通过 NAT 记录了映射实现的，当我们向外网发送请求，NAT 会将内网地址转换成公网地址作为源地址，然后发送出去，并且记录使用的公网的端口以及目的地址和端口，保证可以返回给正确的内网地址。

对于我们开在本地的虚拟机，如果使用 NAT 模式，就是在电脑内部又开了一个虚拟局域网，外部根本没办法访问你，除非你主动访问，所以还是这个没啥好担心的，我之前还怕 ip 直接写在 github 上面会被人攻击，专门去一个一个改。🤣

对于虚拟机另外两个常见的网络模式，桥接模式其实就是将你的虚拟机独立出去，去获取 ip，这样连着同一个 wifi，也就是你的同学也能够访问到你的虚拟机了。另一个仅主机模式，无法与外界通信，但是可以与主机通信，虽然完全隔离了，但是这种情况下没办法拉镜像，甚至 `git push` 都做不到，所以兼顾安全性和可用性，NAT 应该是最合适的。

另外一点，我们的 wifi 路由器的无线网络扮演了“线”的角色，我们局域网对应的 wifi 路由背后都会有 NAT，来实现与外部的通信，而我们连接 wifi 的时候，对应的 wifi 路由器会为你的主机分配 ip，也就是说，ip 仅仅是一个临时的 ip，并不具有持久性，随时都会变，但是对于局域网，我们并不需要持久的 ip，所以这是合理的，而我们的 wifi 路由器是如何分配的？我们的 wifi 路由器会实现 DCHP 动态主机配置协议，当你的主机没有 ip 的时候，会发送广播，而对应的路由器会为你分配一个临时的 ip 地址，当你断联，切换到另一个网络时，这个 ip 就会收回。而这个 DHCP 就相当于是你需要申请身份证，你有了身份证才可以进行通信。我们甚至可以通过 wireshark 去截取这段请求！！！比如我断开 wifi 再重连一次：

![image-20250527201924365](image-20250527201924365.png)

回到我们的终端，输入 ipconfig，我们会发现我们有一段地址和这个 10.20.144.46 一模一样！这表示我们申请到了一个私网 ip！

除此之外，针对于我们的数据链路层在内核中还需要对网卡进行编程，如何做到对硬件编程？其实就是将硬件的一部分数据映射到了内核态的内存之中，通过对这部分特定内存进行读写，就可以实现对硬件进行编程了，诸如键盘，鼠标等设备，都是这样实现的。

说实话，看课之前，我看过《图解 tcp/ip》 和《图解 http》，里面涉及到的概念感觉还是不够清楚，对我来说不是很友好，果然，不愧是斯坦福，引入一些可以让我进一步思考的知识，我带着这些问题去查资料，问 ai，感觉很多东西都清晰起来，而且以前看书的时候感觉这些子网， NAT， DHCP 都挺无聊的，现在感觉还挺有意思的。

## 应用层浅析

承接上文，对于操作系统而言，传输层，网络层，数据链路层（除了硬件）都处于操作系统的内核部分，而应用层都位于用户态，是我们自己去编写的，常见的，有 http， webrtc， websocket， sse 都是应用层协议，一般的 web 开发库都会实现这些协议，比如 go 语言官方自带的 net/http 包就是实现了 http 协议。

我们的应用层实现的协议都是基于网络层实现的，换而言之，我们应用层实现的协议都会去调用网络层，也就是操作系统提供的系统调用接口 socket 套接字的 API，通过它我们可以基于 tcp 进行编程，也可以去实现一个应用层协议，甚至是————自定义你自己的应用层协议。这就是所谓的网络层为上层提供服务，其实就是调用的关系。

## 其他

IP 被设计得很简单，他是不可靠，非连接的，但是他也有校验和机制，可以一定程度上进行检查，但是也只能检测 IP 头部，无法检验数据是否完整，但是他仍然会尽最大努力地传输数据。对于完整的数据监测，是传输层的任务了。

我们可以使用 wireshark 去抓包来分析我们 tcp 的三次握手，当然，现在的 wireshark 的界面并不像书里面那样古老，已经相当现代化了，通过设定 tcp.port 和 ip.addr 来抓取我们想要访问的界面的相关的网络请求，这里我们可以看见各种协议对应的报头，当然，对于更详细的访问这个页面会经过那些路由，我们可以在 linux 里面输入 `traceroute` 命令来实现追溯一个你发送的数据报会经过那些地方，虽然，但是我这里不知道怎么回事，只有一跳就结束了😭。

**子网掩码**，我看视频到一半，想起来了学长讲过的子网掩码，回去看了一下，发现与我们划分网络有关，单一的子网掩码只是一个 mask，将子网掩码和我们当前被分配的 IP 进行 AND 运算就可以得到我们当前所处的子网，通常来说，我们所处的子网也是一个私网地址，所以，如果你和你的朋友处于不同的局域网内，尽管你们的子网相同，也无法通信。而我们的子网经过更多的层级，最终才会对应一个公网 ip。什么意思？比如说，一个小区申请到了一个 ip 地址，他就具备了"联网"的能力，而它可以给许多儿子也赋予这个能力，它的儿子就又具备了这个能力，换句话说，具备了公网 ip 池的小区（这里只是类比），本质上也是一个 "wifi" 路由，它可以为许多 "wifi" 划分子网段，使得产生了更多的 "wifi" ，就是这样一个树的结构，最终对应到了我们所看见的一个办公室的 wifi，一个家庭里面的 wifi。（虽然现实里面是运营商在真正给你分配，但是这里仅仅是类比）

对于 ARP 他是一个地址解析协议，我们网络中每个数据报需要跳到下一个节点都需要知道底层的物理地址，而我们报文仅仅包含目的地的 ip 地址，怎么办？进行下一跳，我们会从路由表中查询发给谁，从而拿到下一跳的 ip 地址，然后本地还会维护一个缓存，对应了 ip 到物理地址的映射，如果本地不存在我们需要的 ip，我们的这个节点就会向当前网络发送一个广播，问谁是这个 ip？然后对应这个 ip 的节点会返回响应，附带自己的物理地址，然后就可以进行下一跳，当然，如果当前网络这个 ip 不存在咋办？此时会返回 ICMP 不可到达消息。

当我们处于局域网的客户端向处于公网的服务端发送请求之后，服务端理所应当可以接收到请求，但是对于处于局域网的客户端如何返回请求呢？首先，我们的客户端首先会经过路由器，这个路由器会将私网地址映射到对应的公网地址，但是这个公网地址对应着很多私网 ip，所以我们还会分配一个唯一的端口号，并且将这个映射关系记录在 NAT 表里面，这样当我们服务器返回信息的时候，就可以根据这个映射来实现转换了！