# xv6部分源码阅读

## 前言

在lab2中，我们会为了完成attack这个实验，而花费大量的时间去阅读相关的系统调用源码，以此来分析出我们最终secret所在的页表的位置，而我写lab2中，重点并没有关注其中的逻辑关系，有很多想仔细分析的函数都没有深入地去看，故写此文，以便理解记忆。

## proc

要想搞清楚proc所分配的页表，首先，还得了解我们的proc是什么样子的：

```c
// 每个进程的状态
struct proc {
  struct spinlock lock;       // 保护进程状态的锁

  // 在使用以下字段时必须持有 p->lock 锁：
  enum procstate state;        // 进程的当前状态
  void *chan;                  // 如果非零，表示进程正在 chan 上睡眠
  int killed;                  // 如果非零，表示该进程已经被杀死
  int xstate;                  // 进程退出时返回给父进程的退出状态
  int pid;                     // 进程 ID
  int tracing;                 // 跟踪系统调用的掩码

  // 必须持有 wait_lock 锁才能使用以下字段：
  struct proc *parent;         // 父进程

  // 这些字段是进程私有的，因此不需要持有 p->lock 锁：
  uint64 kstack;               // 内核栈的虚拟地址
  uint64 sz;                   // 进程内存大小（字节数）
  pagetable_t pagetable;       // 用户页表
  struct trapframe *trapframe; // trampoline.S 中使用的数据页面
  struct context context;      // 切换到该进程时的上下文
  struct file *ofile[NOFILE];  // 打开的文件
  struct inode *cwd;           // 当前工作目录
  char name[16];               // 进程名称（用于调试）
};
```

我们的重点便是下半部分，kstack就是我们的内核栈的虚拟地址的指针，当我们进程需要执行系统调用的时候，我们首先会通过trampoline保存我们的上下文数据(寄存器中的数据)，保存到哪？每一个proc都有可能执行系统调用，所以不能将他们存放在同一个地方，所以，我们的proc结构体还维护了一个trapframe字段，用来我保存我们在执行系统调用之前的上下文，以便于返回时恢复状态，我们可以在trampoline.S里面轻易地看见，保存上下文的代码：

```assembly
  ....
  sd ra, 40(a0) 
  sd sp, 48(a0) 
  sd gp, 56(a0)
  sd tp, 64(a0) 
  sd t0, 72(a0) 
  .....
```

其中的a0，表示我们的trapframe的地址，ra/sp等表示我们执行系统调用之前的寄存器，这就表示将这些寄存器保存到我们的trapframe中，他作为一个单独的页表分配，而在返回的时候恢复上下文的代码，我们也可以在trampoline.S中找到：

```assembly
  ...
  ld ra, 40(a0)
  ld sp, 48(a0)
  ld gp, 56(a0)  
  ld tp, 64(a0) 
  ld t0, 72(a0) 
  ...
```

这就表示从trapframe中获取信息，并赋予寄存器。

在这里我们可以重新理一下之前做过的lab2，刚开始，可能很多人都对trapframe和trampoline不是很理解，实际上，trapframe就是我们需要开辟的新空间，为我们进程保存上下文，恢复上下文服务的，而trampoline是我们所有的进程通过用户页表映射到同一个地方，公共的部分，所有的用户页表都会映射到这个位置，而我们的三级页表实际上也需要分配一个页表来将我们的trampoline和trapframe映射到真正的物理地址上面，最终，我们的proc是如下的映射结构：

```c
VPN2[511]
 └── VPN1[511]
      └── VPN0
           ├── [511] → trampoline
           └── [510] → trapframe

```

VPN2是我们根页表，也就是最开始创建的页表，随后调用**mappages**的时候，就会自动创建二级页表，自动创建三级页表(最开始只有VPN2)，然后才能建立我们的映射关系。

所以这里的proc_pagetable一共创建了三个页表，也就可以解释了。

## exec

这也是一个相当有趣且复杂的系统调用，我在做lab的时候，没有看见需要去阅读源码的准备工作，所以最开始就给没看，写起lab来也是很吃力的。

想要去理解这个exec，就得明白，他是干什么的，exec事实上，在lab1里面也见识了很多次

首先，我们的exec在最开始初始化了一大堆值，我们目前先不关心他，我们要知道，在最开始，我们的exec调用了

```c
  begin_op();
```

这个函数，有啥用？事实上，每一个文件操作之前，前面都会跟上一个begin_up，下面是他的具体实现：

```c
void begin_op(void)
{
  // 获取日志锁，确保对日志操作的独占访问
  acquire(&log.lock);
  // 循环直到可以开始新的文件系统操作
  while(1) {
    // 如果当前日志正在提交，等待提交完成
    if (log.committing) {
      // 当前日志正在提交，休眠并等待提交完成
      sleep(&log, &log.lock);
    } 
    // 如果当前操作可能会超出日志的空间，等待日志提交
    else if (log.lh.n + (log.outstanding + 1) * MAXOPBLOCKS > LOGSIZE) {
      // 当前操作可能耗尽日志空间，休眠并等待提交
      sleep(&log, &log.lock);
    } 
    else {
      // 当前操作可以进行，增加待处理操作的计数
      log.outstanding += 1;
      // 释放日志锁，允许其他线程访问日志
      release(&log.lock);
      // 成功开始文件系统操作，跳出循环
      break;
    }
  }
}
```

我们可以看到，事实上，这就是一个加上一个锁的操作，而是通过日志加锁，来保证每个文件操对日志操作的原子性，顺序性，但是这里竟然是全局锁，哈人。通过加这样一个锁，我们对日志的操作就实现了原子性，随后，我们会从文件系统中寻找我们需要执行的系统调用：

```c
  if((ip = namei(path)) == 0){
    end_op();
    return -1;
  }
  ilock(ip);
```

ilock实际上就是锁定该文件，防止其他进程修改

随后，我们需要读取这个文件，然后对这个文件进行一些验证，随后分配空间：

```c
  // 从 inode 所代表的文件中读取 ELF 头部（ELF Header）到 elf 结构体中
  // 参数含义：
  //   ip：表示打开的文件 inode
  //   0：表示这是从用户空间发起的（传 0）
  //   (uint64)&elf：读取到内存 elf 的地址
  //   0：从文件开头开始读
  //   sizeof(elf)：读取字节数等于 ELF 头的大小
  if(readi(ip, 0, (uint64)&elf, 0, sizeof(elf)) != sizeof(elf))
    goto bad;  // 如果读取失败或读取长度不足，则跳转到错误处理
  // 检查读取到的 ELF 文件头的魔数是否匹配
  // ELF_MAGIC 是一个特定的常数（0x464C457F），用来判断文件是否为 ELF 格式
  if(elf.magic != ELF_MAGIC)
    goto bad;  // 如果不是 ELF 文件，即魔数不对，跳转到错误处理
  // 为当前进程 p 创建一个新的用户页表
  // 旧的页表包含的是之前进程的地址空间，现在要执行新程序，因此需要一个全新的页表
  if((pagetable = proc_pagetable(p)) == 0)
    goto bad;  // 分配失败时跳转到错误处理
```

之后，还会进行一系列验证，最终，会将我们的elf文件的段数据写入内存，总体验证过程和流程如下：

```c
for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
    // 从 ELF 文件中读取每个程序头（Program Header）到 ph 结构体
    if(readi(ip, 0, (uint64)&ph, off, sizeof(ph)) != sizeof(ph))
        goto bad;
    // 如果程序头的类型不是 ELF_PROG_LOAD（表示可加载的程序段），跳过当前程序头
    if(ph.type != ELF_PROG_LOAD)
        continue;
    // 程序段的内存大小必须大于或等于文件大小，否则不合法，跳转到错误处理
    if(ph.memsz < ph.filesz)
        goto bad;
    // 如果程序段的结束地址小于起始地址，说明程序头出错，跳转到错误处理
    if(ph.vaddr + ph.memsz < ph.vaddr)
        goto bad;
    // 程序段的起始地址必须是页面大小对齐的，否则跳转到错误处理
    if(ph.vaddr % PGSIZE != 0)
        goto bad;
    // 为程序段分配内存，确保分配的内存区域是连续的，并且不会与其他程序段冲突
    uint64 sz1;
    if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == 0)
        goto bad;
    sz = sz1;
    // 将 ELF 程序段的数据加载到内存中
    if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) < 0)
        goto bad;
}
```

一旦发现错误，就会立刻跳转到错误处理的地方，而最后，我们会将loadseg加载到页表中：

```c
static int
loadseg(pagetable_t pagetable, uint64 va, struct inode *ip, uint offset, uint sz)
{
  uint i, n;
  uint64 pa;
  // 遍历程序段的每一页（PGSIZE大致为4KB）
  for(i = 0; i < sz; i += PGSIZE){
    // 获取当前虚拟地址（va + i）对应的物理地址
    pa = walkaddr(pagetable, va + i);
    // 如果无法找到对应的物理地址，发生错误
    if(pa == 0)
      panic("loadseg: address should exist");
    // 判断当前页是否是最后一页，如果是，则计算实际读取的大小
    if(sz - i < PGSIZE)
      n = sz - i;
    else
      n = PGSIZE;
    // 从文件（inode）中读取数据到物理地址 pa 上
    if(readi(ip, 0, (uint64)pa, offset+i, n) != n)
      return -1;  // 如果读取失败，返回错误
  }
  return 0;  // 成功加载所有数据
}
```

实际上，loadseg对于我们并不是过于重要，我们只需要知道，他会将我们给的段写入到单独的内存页，这样就行了。

那么，将段单独写入内存页的逻辑在哪？其实我们已经见识过了：

```c
for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph))
```

这里的for循环，就是将我们的程序段循环遍历的地方，通过这样，我们可以将符合要求的段加入我们的页表中，即便我们不知道有多少个段，我们也可以加一个printf语句来帮助我们判断，从而弄清楚到底分配了几个页。

至此，我们就搞清楚了我们的页表是如何分配的了

但是，到目前为止，我们仅仅是将我们的页表给分配了，并且将我们的段都写入进去了，我们还需要分配我们的栈空间

```c
  // 将当前地址 sz 向上对齐到页边界，为用户栈分配内存页（至少 USERSTACK + 1 页）
  // 第一页作为 "栈保护页"，不可访问；剩下的 USERSTACK 页是实际的用户栈
  sz = PGROUNDUP(sz);  // 保证下一次页分配是对齐的
  uint64 sz1;
  if((sz1 = uvmalloc(pagetable, sz, sz + (USERSTACK+1)*PGSIZE, PTE_W)) == 0)
    goto bad; // 分配失败，跳转错误处理
  sz = sz1;

  // 清除栈底的 guard 页，即使映射存在也让它不可访问（trap）
  uvmclear(pagetable, sz-(USERSTACK+1)*PGSIZE);

  // 设置 sp（栈指针）和 stackbase（栈底，栈增长不会低于这里）
  sp = sz; // 初始 sp 指向用户栈顶部
  stackbase = sp - USERSTACK*PGSIZE; // 栈的最低地址（不包括 guard 页）
```

当然，我们可以看见除了我们的栈空间，还分配了栈保护页，这是为了防止栈溢出是将其他区域的数据覆盖掉所设置的，当发生栈溢出，访问到保护页的时候，系统就会触发异常。

随后需要初始化我们的栈

```c
// 将命令行参数字符串逐个压入用户栈，同时构建一个 ustack[] 数组，
// 存放每个参数字符串在用户栈中的地址（即 argv[i] 的指针）。
for(argc = 0; argv[argc]; argc++) {
  // 超出限度，就转到错误处理
  if(argc >= MAXARG)
    goto bad;
  // 给这个参数字符串分配空间，长度需要加上结尾的 '\0'
  sp -= strlen(argv[argc]) + 1;
  // 内存对齐
  sp -= sp % 16;
  // 如果当前栈指针已经低于栈底，说明栈空间不够，返回错误
  if(sp < stackbase)
    goto bad;
  // 把参数字符串从内核拷贝到用户页表的栈空间（虚拟地址为 sp）
  if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
    goto bad;
  // 将我们每个参数的指针放在数组里面。
  ustack[argc] = sp;
}
// 添加 NULL 结尾，相当于 argv[argc] = 0，表示参数结束
ustack[argc] = 0;
```

可以看见，我们主要将我们的参数通过sp拷贝到用户的栈空间中，并且初始化了一个ustack数组来存储这些sp指针，他在之后会显现他的作用：

```c
// 这里是为我们需要拷贝的数据腾出栈空间
// 所以需要改变指针栈指针
  sp -= (argc+1) * sizeof(uint64);
// 内存对齐
  sp -= sp % 16;
  if(sp < stackbase)
    goto bad;
// 将我们的ustack数组的指针数组拷贝到栈空间中，我们之后便能通过ustack中存储的sp指针
// 去找到对应的参数
  if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) < 0)
    goto bad;
```

综上，我们将ustack拷贝到栈空间，随后我们就可以轻易地通过这个数组存储的指针，访问到相对应的参数了，为啥要通过ustack访问？这是为了保证我们栈访问的安全性，统一性。

最后，便是我们的收尾工作了，我们的exec真的要结束了：

```c
// 将栈指针 (sp) 保存到 trapframe 的 a1 寄存器。
// 这个栈指针将在用户程序中使用，'sp' 指向用户栈。
p->trapframe->a1 = sp;

// 保存程序名以便调试。
// 从完整路径中提取程序名（即最后一个 '/' 后的部分）。
for(last = s = path; *s; s++)
    if (*s == '/')          // 查找路径中的最后一个 '/'
        last = s + 1;       // 程序名从 '/' 后开始
safestrcpy(p->name, last, sizeof(p->name));  // 将程序名复制到进程名称中，方便调试

// 提交新的用户空间镜像，通过切换页表和更新进程状态来完成。
// 保存当前的（旧的）页表
oldpagetable = p->pagetable;
// 设置新的页表
p->pagetable = pagetable;
// 更新进程的大小
p->sz = sz;
// 设置进程的初始程序计数器（epc）为 ELF 文件的入口点
p->trapframe->epc = elf.entry;  // 初始程序计数器 = main 函数的地址
// 设置栈指针（sp）为用户空间的栈指针
p->trapframe->sp = sp; // 初始栈指针
// 释放旧的页表资源
proc_freepagetable(oldpagetable, oldsz);
```

我们这里主要是将栈指针的起始位置存入我们的trapframe，a0保存的是我们的系统调用号，而a1则是我们的参数列表的栈指针。这一步已经完成了，最后的，那就是我们的首位工作，将各个参数更新，除此之外，还需要将我们的旧的页表给释放掉，这样，便可以返回我们了，这样，我们的程序就可以去执行我们的程序了。



