# lab-2

## 0. 前置

### **课程记录**

> 操作系统的**隔离性**，举例说明就是，当我们的shell，或者qq挂掉了，我们不希望因为他，去影响其他的进程，所以在不同的**应用程序**之间，需要有隔离性，并且，应用程序和操作系统之间，也是如此。
>
> 当失去操作系统，我们的应用程序将会**直接**与硬件进行交互，数据也将直接存储在**物理内存**中，但是我们的两个应用程序无法识别相互的**边界**，此时就可能会产生**覆盖**，所以，这就是我们希望内存能够隔离的原因，也是我们操作系统所需要实现的功能，另外还需要**multiplexing**(cpu分时复用，也就是多线程，CPU运行一个进程一段时间，再运行另一个进程)
>
> 这里也有一层抽象，操作系统没有直接将cpu提供给应用程序，而是将进程抽象了cpu，这样操作系统才能在多个应用程序之间复用一个或者多个cpu。
>
> 而我们也可以认为exec是对内存的抽象，通过提供exec这样一个系统调用，使得我们可以安全的访问对应的内存，而我们不能够直接访问物理内存。
>
> files，它提供了方便的磁盘抽象，我们唯一与存储系统交互的方式就是files，我们可以任意改写这个文件，而最终，由操作系统来决定，这个files如何与磁盘中的块对应。

---

> 操作系统的**防御性**，操作系统需要确保所有的应用程序都能工作，因此，操作系统不能没有任何抵御攻击的准备，比如说，应用程序向**系统调用**中传递了错误的参数，而导致了操作系统的**崩溃**，进而导致操作系统**拒绝**了为其他所有应用程序提供服务，所以操作系统需要能够应对恶意的程序。
>
> 并且应用程序也不能打破隔离性，而影响到其他的程序，甚至控制内核(很危险)。
>
> 通常来说，**强隔离性**由硬件实现，包括**user/kernel mode**和**虚拟内存**。
---

> 首先，为了支持**user/kernel mode**，处理器也会有两种操作模式，不同的操作模式权限不同，kernel mode可以使用特权命令，而user mode只能使用普通权限命令。
>
> 特权命令，比如说设置page table寄存器，以及处理器的相关状态等。
>
> 当在user mode 执行了特权命令，cpu会拒绝这条命令，并且转入kernel mode，杀死这个进程。
>
> kernel mode还是user mode是通过一个flag寄存器来存储的。
>
> **page table**，每个进程都会有自己的一个独立的page table，也就是说，每个进程都有自己独立的视图，而进程在这个视图上去访问内存空间，从而被映射到物理地址中，这样来保证他们的内存不会重合。

---

> **user/kernel mode**是如何切换的？xv6中，我们在make之后，我们可以在user/usys.S找到ecall这个指令，事实上，通过ecall这个指令，我们能够跳转到内核中指定的由内核控制的位置来执行系统调用。
>
> 举一个例子，当我们调用fork，或者read的时候，事实上没有直接调用函数，而是通过ecall去跳转到内核，执行系统调用。
>
> 现在我们有了可以执行系统调用的手段，之后内核负责实现具体的系统调用，并且需要检查参数，防止被恶意攻击，所以安全可靠无bug的内核也成为TCB(Trusted Computing Base)
>
> **宏内核**：xv6就是一个宏内核的典型代表，所有的操作系统服务都在kernel mode中，由于任何一个操作系统的bug都有可能成为漏洞，而我们有大量的代码放在内核中，出现漏洞的可能性就更高了，这便是宏内核的缺点，而宏内核的另一个代表就是linux，宏内核的优势在于包括文件系统，虚拟内存等子模块都集成在一个程序中，提供了很好的性能。
>
> **微内核**：微内核和宏内核恰恰相反，他将大部分操作系统运行在内核之外，这样可以有效减少内核的代码数量，从而降低出现漏洞的概率，但是微内核也有缺陷，比如说在shell需要与文件系统交互的时候，内核实际上是以消息传递的形式来执行系统调用的，这种情况下，每个操作都需要执行两次跳转，所以性能是更差的。并且，在一个宏内核中，如文件系统和虚拟内存系统可以轻易地共享page cache，但是在微内核中，这些模块都被隔离开了，而这种共享难以实现，也使得难以获得更高的性能。
>
> 到分析xv6启动过程的时候，我发现只看文档，确实还是很不理解的，推荐有实践，带着看代码的部分还是看视频最好。

---

### **xv6手册**

**进程**

进程具有独占的地址空间，以及看上去是仅在运行当前程序的cpu，而其他进程无法对其进行干扰，这样，它就会误以为自己运行在独立一台机器上。

xv6使用页表(硬件实现)为每个进程提供独有的地址空间，而页表将虚拟地址(汇编使用的地址)映射为物理地址(处理器芯片向主存发送的地址)。

从低地址区开始，依次代表着用户(低处存放进程的指令)->全局变量->栈区->堆区

同样的，内核的指令和数据也都被映射到了每个进程的地址空间中的高地址处(为用户留下足够的空间)，当进程使用系统调用的时候，就会跳转到**进程地址空间**的**内核区域**执行(感觉和中断有点像)，而在xv6中，使用的是**proc**来维护的一个进程的状态(包含了页表，内核栈，运行状态等信息)。

每个进程都有自己的用户栈和内核栈，当进程运行用户命令时，只有用户栈被使用，内核栈是空的，在进行系统调用或者中断进入内核的时候，内核代码就会被放入内核栈中执行，用户栈依旧保存着数据，只是现在不活跃，进程的线程交替使用内核栈和用户栈，而用户代码无法操作内核栈，所以即便用户破坏了自己的用户栈，内核也能正常运行，梳理一下流程：

> 进程系统调用 -> 处理器转入内核栈中(或者说指令指针改变到内核栈中) -> 提升硬件特权 -> 运行特权代码 -> 降低特权 -> 转回到用户栈

而我们每个进程都会有一个线程，线程之间的切换，实际上就是挂起当前线程，恢复另一个线程的状态，线程的状态都保存在线程栈上。(有点像中断时的寄存器状态的恢复和保存)

开机后发生的事情：他会初始化自己，将bootloader从磁盘中载入，而bootloader负责将内核从磁盘中载入，随后开始运行`entry`，而entry的最开始，设置了两份页表映射，(低地址的映射和高地址的映射)，因为在最开始，还没有设置页表的时候，我们的机器很可能没有虚拟地址对应的那么大的内存，于是，我们只能将其对应到物理地址上，然后我们会设置这两份页表映射，因为最开始entry还运行在内存的低地址处，所以需要设置 `0:0x400000 -> 0:0x400000`的映射关系，我们还需要设置一个高地址的映射关系KERNBASE:KERNBASE+0x400000 -> 0:0x400000，而kernbase指的就是 0x80000000。

配合这张图会比较好理解。

![figure1-2](C:\Users\chenyue\Desktop\PrOJECT\Notes\Note\操作系统\assets\f1-2.png)

然后entry会继续设置页表，并且将页表的目录`entrypgdir`的物理地址载入`%cr`，此时就可以通过各种操作去实现分页机制了(这里有一些比较底层的没看懂)

最后，entry就需要跳转到内核的C代码，并且在内存的高地址去执行它了

这里我还有很多地方都没看懂，感觉这里还是主要讲的是x86的？有的部分还是自己去看看源代码比较好，我看2024年的源代码，riscv的汇编部分是很少的，也就300行左右，大部分还是c语言，包括很多操作系统的cpu，进程调度啥的，也没看懂，这里分享一下我和AI大战三百回合了解到的东西(不一定对)：

操作系统本质上也是一个进程，也需要一个cpu去执行，而在操作系统启动后，cpu就会不断去执行我们提前写好的代码(执行程序的机器)，而所有cpu的CS:IP，也就是执行程序的指针，都由操作系统这个特殊的进程来调度，但是，如果到最后，没有任何程序可以供cpu执行，那么cpu就会陷入一个空闲循环，因为cpu总是应该执行的，然后，当我们新建了一个进程，需要cpu去执行的时候，就会获取一个cpu，同时修改他的CS:IP使他的指令指针指向这个进程的起始位置，然后将相关的上下文切换，cpu便能继续执行新的工作，当然在后面的调度，我们还会知道，时间片耗尽的中断机制，当然，这是后面的话题了。

其实这方面最开始最困扰我的就是，你的CPU他怎么知道他何时应该执行程序？CPU在操作系统没有启动的时候，不是陷入睡眠吗？启动操作系统之后，就能向下执行命令，cpu难道是个只会工作的机器吗？cpu并不是一开始就在运行吧？我们如果创建一段程序，想要去执行它，除了设置它的状态为RUNNING，并且表示他能够呗调度，但是实际上，cpu怎么知道，他应该去执行什么呢？ 或者说，cpu怎么知道，他何时应该执行命令？ 毕竟即便是汇编代码，想要cpu开始去执行，让他的CS:IP开始偏转，不也需要去运行这个程序吗？然而我们就是把它的状态标记成RUNNING，这合适吗？还有什么其他的步骤？

其实现在一想，自己的一些疑问也有点意思，但是同时理解了之后，回答这些疑问也是比较轻松的，不知道自己和AI大战之后得出来的结论正确没有，如果有什么错误，希望给我能留言!

----

## 1. trace

