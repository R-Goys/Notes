# lab-2

## 前置

###  第一章

**进程**

进程具有独占的地址空间，以及看上去是仅在运行当前程序的cpu，而其他进程无法对其进行干扰，这样，它就会误以为自己运行在独立一台机器上。

xv6使用页表(硬件实现)为每个进程提供独有的地址空间，而页表将虚拟地址(汇编使用的地址)映射为物理地址(处理器芯片向主存发送的地址)。

从低地址区开始，依次代表着用户(低处存放进程的指令)->全局变量->栈区->堆区

同样的，内核的指令和数据也都被映射到了每个进程的地址空间中的高地址处(为用户留下足够的空间)，当进程使用系统调用的时候，就会跳转到**进程地址空间**的**内核区域**执行(感觉和中断有点像)，而在xv6中，使用的是**proc**来维护的一个进程的状态(包含了页表，内核栈，运行状态等信息)。

当进程运行用户命令时，只有用户栈被使用，内核栈是空的，在进行系统调用或者中断进入内核的时候，内核代码就会被放入内核栈中执行，用户栈依旧保存着数据，只是现在不活跃，进程的线程交替使用内核栈和用户栈，而用户代码无法操作内核栈，所以即便用户破坏了自己的用户栈，内核也能正常运行，梳理一下流程：

> 进程系统调用 -> 处理器转入内核栈中(或者说指令指针改变到内核栈中) -> 提升硬件特权 -> 运行特权代码 -> 降低特权 -> 转回到用户栈

而我们每个进程都会有一个线程，线程之间的切换，实际上就是挂起当前线程，恢复另一个线程的状态，线程的状态都保存在线程栈上。(有点像中断时的寄存器状态的恢复和保存)

开机后发生的事情：他会初始化自己，将bootloader从磁盘中载入，而bootloader负责将内核从磁盘中载入，随后开始运行`entry`，而entry的最开始，设置了两份页表映射，(低地址的映射和高地址的映射)，因为在最开始，还没有设置页表的时候，我们的机器很可能没有虚拟地址对应的那么大的内存，于是，我们只能将其对应到物理地址上，然后我们会设置这两份页表映射，因为最开始entry还运行在内存的低地址处，所以需要设置 `0:0x400000 -> 0:0x400000`的映射关系，我们还需要设置一个高地址的映射关系KERNBASE:KERNBASE+0x400000 -> 0:0x400000，而kernbase指的就是 0x80000000。

配合这张图会比较好理解。

![figure1-2](C:\Users\chenyue\Desktop\PrOJECT\Notes\Note\操作系统\assets\f1-2.png)

然后entry会继续设置页表，并且将页表的目录`entrypgdir`的物理地址载入`%cr`，此时就可以通过各种操作去实现分页机制了(这里有一些比较底层的没看懂)

最后，entry就需要跳转到内核的C代码，并且在内存的高地址去执行它了

----

