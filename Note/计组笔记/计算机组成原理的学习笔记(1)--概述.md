## 学习笔记



### 一、hello.c如何运行起来？

#### 1. 预处理阶段

- 在编译 C 程序时，预处理器首先处理代码。预处理器会：
  - **插入头文件**：例如，当在代码中使用 `#include <stdio.h>` 时，预处理器会将 `stdio.h` 中的内容插入到源代码中。这样，编译器在处理时就得到了所有必要的函数声明和宏定义。
  - **宏替换和条件编译**：将所有的宏定义替换为实际值，并处理任何条件编译的指令（如 `#ifdef`）。

#### 2. 编译阶段

- 在预处理完成后，源代码被传递给编译器进行编译：
  - **生成汇编代码**：编译器根据插入的头文件内容以及主程序生成汇编代码，在这一阶段，编译器已经知道程序中需要调用哪些函数（比如 `printf`），当编译器解析完成的代码时，遇到
  
    ```
    MyPrint
    ```
    
    等函数调用时，编译器会查看之前包含的头文件，以识别该函数的声明，比如：
  
    ```c
    void MyPrint(char* x);
    ```
  
    此时，编译器知道MyPrint函数的参数类型和返回类型，但并不知道其具体的实现位置（内存空间中的位置），于是我们需要进行链接。

#### 4. 链接阶段

- 当编译完成后，链接器负责将目标文件与其他目标文件和库合并：
  - **符号解析**：链接器检查目标文件中的所有符号（如函数调用），并寻找它们在其他目标文件或库中的定义。例如，`printf` 函数的实现通常在 C 标准库中。
  - **地址分配**：链接器为所有函数、变量和程序段分配实际内存地址。
  - **重定位**：对于目标文件中的调用指令，链接器会将它们更新为实际的内存地址，使得在运行时这些调用能够正确指向其实现的实体部分。

#### 小总结

在整个过程中，预处理器将头文件的内容插入到源代码中，使编译器能够识别所有需要的函数。然而，在这一阶段，编译器并不知道这些函数的实际实现位置。链接的主要目的是解析这些函数（和变量）引用的地址，确保在最终可执行文件中，所有调用都能够正确链接到其实现。这样，程序在运行时就能够顺利执行所有的函数调用，功能才能正常运作。

### 二、计算机硬件的工作流程


#### 1.指令取出的流程

##### 组件解释

- **PC (Program Counter)**:
    - 程序计数器是一个寄存器，存储下一条将要执行指令的地址。每当 CPU 取出一条指令后，PC 会更新为下一条指令的地址。

- **MAR (Memory Address Register)**:
  - 内存地址寄存器，用于存储当前要从内存中读取或写入的地址。当从内存中取指令时，PC 的内容会传送到 MAR。


- **M (Memory)**:
   - 主存储器，通常是随机存取存储器（RAM）。它用于存储程序和数据。MAR 指定的地址中的内容即为存储的指令或数据。
- **MDR (Memory Data Register)**:
   - 内存数据寄存器，用于临时存储从内存中读取的数据或准备写入内存的数据。当通过 MAR 指定的地址访问内存时，读取的数据将首先存储到 MDR 中。
- **IR (Instruction Register)**:
   - 指令寄存器，存储当前正在执行的指令。当从 MDR 中获取到指令后，这条指令将被加载到 IR 中以进行解码和执行。

关于老师所讲到的顺序，整个指令取出和执行流程可以描述如下：

- **取指**:

   - CPU 从 PC 读取下一条指令的地址并将其传送到 MAR：

     ```
     PC -> MAR
     ```

- **访问存储器**:

   - 通过 MAR 指定的地址，CPU 发出读取命令，从内存中获取数据（指令）：

     ```
     M[MAR] -> MDR
     ```

   - 这里 `M[MAR]` 表示从内存中的 MAR 地址读取数据，并将其存储到 MDR 中。

- **加载指令**:

   - 当指令从内存读入 MDR 后，它被传送到 IR 进行处理：

     ```
     MDR -> IR
     ```

- **执行指令**:

   - PC 增加以准备下一条指令的读取，IR中的指令被解码和执行。

#### 2.分析指令
```
OP(IR)->CU
```
##### 组件解释
- **操作码（OP）**
  
  - 操作码是指令中用于指定要执行的操作的部分。例如，它可以指示进行加法、减法、存储、加载或逻辑运算等操作。
- **控制单元（CU）**
  - 控制单元是中央处理器（CPU）中的一个重要组成部分，负责协调和控制计算机的操作。它从指令寄存器（IR）中获取操作码，并根据其内容生成相应的控制信号。

1. **指令提取**：当 CPU 从内存读取指令后，这指令被加载到指令寄存器（IR）中。
2. **操作码提取**：IR 中的操作码部分被提取出来，准备传递给控制单元。这可以是一条指令的开头部分，表示要执行的操作。
3. **解码**：CU 接收到操作码后，开始解码过程，并判断应该执行什么操作。
4. **产生控制信号**：CU 根据操作码生成对应的控制信号，指示 ALU、寄存器、内存和其他硬件单元该如何操作。

#### 3.执行指令

##### 组件解释

   1. **IR (Instruction Register)**:
      - 指令寄存器，用于存储当前正在执行的指令。它包含指令的操作码和地址。
   2. **MAR (Memory Address Register)**:
      - 内存地址寄存器，用于存储当前要访问的内存地址。它可以接收来自 IR 的地址部分。
   3. **M (Memory)**:
      - 主存储器，存储程序和数据。通过 MAR 指定的地址访问存储器，读取相应的内容。
   4. **MDR (Memory Data Register)**:
      - 内存数据寄存器，用于临时存储从内存中读取的数据，或者准备写入内存的数据。
   5. **ACC (Accumulator)**:
      - 累加器，通常用于存储运算的结果或中间值，负责执行算术和逻辑运算。

##### 流程说明

- **1. 指令地址提取**
  
	- 从指令寄存器（IR）提取出要访问的地址（Ad）部分，然后将这个地址加载到内存地址寄存器（MAR）中。这一步通常是指令解码的一部分。
	```
	Ad(IR) -> MAR
	```
- **2. 访问内存**
  - MAR 中的地址现在指向特定的内存位置，CPU 发出请求以从该地址读取数据（指令的操作数或者其他数据）。

	```
	MAR -> M
	```
- **3. 存储读取的数据**

  - 从内存读取的数据将被加载到内存数据寄存器（MDR）中，MDR 临时存储着这些数据，待后续使用。
  ```
  M ->MDR
  ```
- **4. 数据转存到累加器**

  - 最终，数据从内存数据寄存器（MDR）转移到累加器（ACC）中。此时，ACC 可以用于进一步的算术运算或逻辑运算。

  ```
  MDR -> ACC
  ```

#### PC更新
- **顺序执行**：在执行完一条指令后，PC 会自动增加，通常增加的值等于指令的长度（例如，对于 4 字节长的指令，PC 增加 4），指向下一条顺序执行的指令。
- **跳转指令**：如果当前指令是跳转指令，PC 将更新为指定跳转目标的地址，而不是顺序增加。

### 总结

​	关于这个笔记，我详细记录了有关工作运行逻辑的内容，对于概念之类的涉及较少，有需要可以去b站上看尚硅谷原视频，那里有更详细的关于概念的讲解。
