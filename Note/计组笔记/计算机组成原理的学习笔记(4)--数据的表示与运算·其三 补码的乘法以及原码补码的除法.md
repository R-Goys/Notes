## 1.补码乘法

### 基本操作
   - 与正常原码乘法差不多，逐位乘，随后相加，而与符号位有关的一项也叫校正项


### Booth算法
   - 从乘数的最低位开始，逐位检查乘数的当前位和前一位（即“当前位”与“上一位”组合）：
     - **`00`**：不操作。
     - **`01`**：加上被乘数（表示乘数当前位为1，当前计算为加法）。
     - **`10`**：减去被乘数（表示乘数当前位为-1，当前计算为减法）。
     - **`11`**：不操作。

### 校正项

- 在Booth算法的处理中，校正项直接成为了”完美公式“中的重要组成部分，而在视情况校正法之中像个多余的。

------

## 2. 原码除法的加减交替法

### 基本原理

在原码除法中，**加减交替法**通过判断当前被除数是否大于或等于除数，决定是否执行减法（相当于商1）或不执行任何操作（商保持不变）。

### 基本操作：
1. **计算**

  每次判断当前的部分余数（即当前余数与除数的比较结果），根据余数和除数的大小，决定是否加除数或减除数：

-	如果余数 ≥ 除数：

    - 	执行减除数操作：余数减去除数。
    - 	商的当前位加 1。
    
 - 如果余数 < 除数：
   
    - 执行加除数操作：余数加上除数。
    
    - 商的当前位保持不变。
    
  - 在每次操作后，余数向左移动一位(×2)，商的当前位更新。
2. **商的符号**：
   - 商的符号由被除数和除数的符号决定：
     - **同号** → 商为正。
     - **异号** → 商为负。

------

## 3. 补码除法中的加减交替法

**关于原视频的理解方式稍微有一点困难，这里分享一下我的看法**。



### 我的思路

- 在补码除法中，可以通过符号的分析来判断是否“够减”，从而确定商的更新规则。
  - **符号一致**（余数和除数符号相同）：认为“够减”，商进一。
  - **符号不一致**（余数和除数符号不同）：认为“不够减”，商不变。

### 老师的想法

- 视频中的讲解我也同样进行了思考，该方法主要是通过绝对值来比较，在这里，**是否够减**判断的依据我总结为：
  - 根据**被除数的符号和余数的符号**来判断，同号够减，异号不够减
  - 于此同时需要判断**商的符号**来判断进位的原则，分两种情况：
    - 商符号为负，进位则相当于原码中的-1，则此时进位方式和原码除法相反。
    - 商符号位正，进位的方法与原码除法相同。

### 总结
- 通过我的思考方式，感觉容易理解一点，但我不能说这种思路是正确的，也许只是答案正确了，随后可以再进一步理解老师的思路是怎么样的，这样循序渐进更好。

#### Other

- 我去，记笔记到这里，然后往后看发现直接把判断规则简化成“我的思路”的，感觉自己好傻.

- ACC和MQ的作用作为余数寄存器和余数/商寄存器。




------



