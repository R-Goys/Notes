#### 1. **浮点数的表示与运算**

- **规格化数**：

  - 浮点数的存储格式为

    ，其中：

    -  为符号位。
    -  为尾数，通常在0和1之间（规格化形式为1.xxxxx）。
    -  为指数。

- **浮点数加减运算步骤**：

  1. **对齐尾数**：将两个浮点数的尾数对齐，比较它们的指数，右移尾数。

  2. 执行加法或减法：

     - 加法：符号相同的尾数相加。
     - 减法：符号不同的尾数相减。
     
  3. **规格化结果**：调整结果，必要时修改指数。

  4. **处理溢出和下溢**：确保结果在表示范围内。

  5. **舍入**：确保结果尽可能精确。

------

#### 2. **数据存储的边界对齐**

- **边界对齐原则**：

  - 数据在内存中按照特定字节边界进行对齐，提高访问效率。
  - 对齐要求通常等于数据类型的大小。
    - `char`：1 字节
    - `short`：2 字节
    - `int`：4 字节
    - `float`：4 字节
    - `double`：8 字节

- **结构体对齐**：

  - 结构体的大小通常是其最大成员对齐大小的倍数。
  - 结构体成员之间可能会引入填充字节，以满足对齐要求。

- **示例**：

  ```c
  struct Example {
      char a;   // 1 byte
      int b;    // 4 bytes
      char c;   // 1 byte
  };
  // 实际存储大小可能是 12 字节，包含填充字节。
  ```
 - 值得注意的是，当结构体中变量定义的顺序不同，结构体所占据的空间也会不同，具体可以看视频的讲解

------

#### 3. **字节序：大端与小端**

- **小端（Little-endian）**：
  - 低字节存储在低地址，高字节存储在高地址。
  - 示例（0x12345678的存储顺序）：
    - 地址0：78
    - 地址1：56
    - 地址2：34
    - 地址3：12
- **大端（Big-endian）**：
  - 高字节存储在低地址，低字节存储在高地址。
  - 示例（0x12345678的存储顺序）：
    - 地址0：12
    - 地址1：34
    - 地址2：56
    - 地址3：78
- **计算机系统中的使用**：
  - 小端：多数现代计算机（如 Intel x86）使用小端字节序。
  - 大端：一些网络协议和特定计算机架构使用大端。
- **字节序转换**：在多平台或网络通信时，需注意字节序问题，确保数据正确解析。

-------

1