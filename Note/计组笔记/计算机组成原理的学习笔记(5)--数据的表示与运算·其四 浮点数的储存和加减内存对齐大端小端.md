# 计算机组成原理的学习笔记(4)--数据的表示与运算·其三 补码的乘法以及原码补码的除法

#### 1. **浮点数的表示与运算**

- **规格化数**：

  - 浮点数的存储格式为

    ，其中：

    -  为符号位。
    -  为尾数，通常在0和1之间（规格化形式为1.xxxxx）。
    -  为指数。

- **浮点数加减运算步骤**：

  1. **对齐尾数**：将两个浮点数的尾数对齐，比较它们的指数，右移尾数。

  2. 执行加法或减法：

     - 加法：符号相同的尾数相加。
     - 减法：符号不同的尾数相减。
     
  3. **规格化结果**：调整结果，必要时修改指数。

  4. **处理溢出和下溢**：确保结果在表示范围内。

  5. **舍入**：确保结果尽可能精确。

------

#### 2. **数据存储的边界对齐**

- **边界对齐原则**：

  - 数据在内存中按照特定字节边界进行对齐，提高访问效率。
  - 对齐要求通常等于数据类型的大小。
    - `char`：1 字节
    - `short`：2 字节
    - `int`：4 字节
    - `float`：4 字节
    - `double`：8 字节

- **结构体对齐**：

  - 结构体的大小通常是其最大成员对齐大小的倍数。
  - 结构体成员之间可能会引入填充字节，以满足对齐要求。

- **示例**：

  ```c
  struct Example {
      char a;   // 1 byte
      int b;    // 4 bytes
      char c;   // 1 byte
  };
  // 实际存储大小可能是 12 字节，包含填充字节。
  ```
 - 值得注意的是，当结构体中变量定义的顺序不同，结构体所占据的空间也会不同，具体可以看视频的讲解

------

#### 3. **字节序：大端与小端**

##### 3.1. **基本概念**

- **小端（Little-endian）**：
  
  - 低字节存储在低地址，高字节存储在高地址。
  - 示例（0x12345678的存储顺序）：
    - 地址0：78
    - 地址1：56
    - 地址2：34
    - 地址3：12
  
- **大端（Big-endian）**：
  
  - 高字节存储在低地址，低字节存储在高地址。
  
  - 示例（0x12345678的存储顺序）：
    - 地址0：12
    - 地址1：34
    - 地址2：56
    - 地址3：78
  
    
  

##### 3.2. **核心依据：硬件设计需求**

  多字节数据（如整数、浮点数）在内存中存储时，需要决定**高位字节**和**低位字节**的顺序：

  - **大端（Big-Endian）**：高位字节存储在低地址，低位字节存储在高地址。
    **示例**：`0x12345678` 存储为 `12 34 56 78`（地址递增方向）。
    **硬件代表**：PowerPC、SPARC、早期的ARM、网络协议（如TCP/IP）。
  - **小端（Little-Endian）**：低位字节存储在低地址，高位字节存储在高地址。
    **示例**：`0x12345678` 存储为 `78 56 34 12`（地址递增方向）。
    **硬件代表**：x86/x64、现代ARM（可配置）、大多数嵌入式系统。

------

##### 3.3. **历史背景与设计哲学**

  - **大端起源**：
    - 符合人类读写习惯（类似十进制数的书写顺序，高位在前）。
    - 早期计算机设计（如IBM大型机）采用大端，因其更直观。
  - **小端起源**：
    - 硬件处理效率更高：例如，加法运算从低位开始，小端存储可直接按地址递增顺序处理进位。
    - 内存访问优化：若需截取低字节（如32位转8位），小端无需计算偏移量。

------

##### 3.4. **实际应用场景的差异**

  - **网络传输**：
    - 网络协议（如IP、TCP）统一采用**大端（网络字节序）**，以确保不同架构设备间的兼容性。
    - 编程中需用 `htonl()`/`ntohl()` 等函数转换本地字节序与网络字节序。
  - **文件格式与跨平台兼容性**：
    - 某些文件格式（如JPEG、PNG）明确要求大端存储。
    - 跨平台数据交换时需处理字节序问题（如二进制文件读写）。
  - **硬件优化**：
    - 小端在内存对齐和数据类型转换中更灵活。例如，32位整数 `0x000000FF` 在小端中可直接作为 `0xFF` 读取（低地址即为最低有效字节）。

------

##### 3.5. **现代处理器的选择**

  - **性能权衡**：
    - 小端架构在低功耗设备中更常见（如ARM），因其硬件实现简单且适合逐字节处理。
    - 大端在特定场景（如网络设备）中仍有优势。
  - **混合模式（Bi-Endian）**：
    - 现代处理器（如ARMv8、MIPS）支持动态切换字节序，兼顾灵活性与兼容性。
  
- **字节序转换**：在多平台或网络通信时，需注意字节序问题，确保数据正确解析。

-------

