# SQL碎片知识

本篇笔记目的在于记录常见的 MySQL 相关的问题。

## 1. 慢查询怎么处理？

查看慢查询日志，通过 explain 分析慢查询的 SQL 语句，查看是否走的全表扫描，或者没有利用索引，随后添加合适的索引，同时查询需要遵循最左匹配原则。

另外也可以进行简化查询，只查询必要的字段，或者使用覆盖索引，或者减少通配符的使用；使用 JOIN 替代嵌套的 SELECT 减少子查询

如果发现这个查询确实走了索引，但是依旧很慢，可能需要分析锁。

## 2. 为啥 MySQL 选择了 B+ 树而不是平衡二叉树或者 B 树？

普通的二叉搜索树在顺序插入索引的时候会导致树退化成链表，这种情况下就相当于全表扫描。

而平衡二叉树或者红黑树性能差异并不大，但是由于每一个节点仅能存储一个索引，所以存储效率很低，在存储成千上万的索引时，树的高度很大，而每一次查找都是一次磁盘 I/O ，所以我们期望高度会比较低的数据结构。

B 树和 B+ 树的高度都比较低，为什么没有选择 B 树？B 树的数据是分布于整个树中的，除了叶子节点，还分布于内节点上面，不利于我们走范围查询，并且查询的速度波动很大，除此之外，这样的性质使得 B+ 树可以存放更多的索引，查询效率更高，磁盘的 I/O 也会更少。

而我们的 B+ 树，它的数据都存储在叶子节点上，而内节点都用于放索引，同时，我们的叶子节点相邻之间构成了双向链表，这种设计非常利于范围查询。 B+ 树存在大量的冗余节点（内节点）这就是的插入和删除的效率很高，树形结构的变化很小，而 B 树由于没有冗余节点，所以删除就会非常复杂，树形变化较大。

## 3. 聚簇索引和二级索引？

一张表只有一个聚簇索引，聚簇索引的叶子节点上存储着完整的数据，而二级索引存储的是对应的“主键”字段，当我们通过二级索引去查询数据时，就会先通过二级索引拿到主键信息，然后根据主键回到聚簇索引之中去查询具体的数据，也就是说，要执行两次 B+ 树查询，这种情况就是**回表**。

当然，如果我们查询的数据已经包含在了索引之中，就无需回表查询，这种情况就是**索引覆盖**。

## 4. MyISAM 和 InnoDB 的区别

MyISAM 的索引是非聚集索引，数据和索引分离，每一个数据查询都需要经过回表的步骤，而 InnoDB 有聚集索引，通过主键检索的效率很高。

MyISAM 最细粒度的锁是表锁，而 InnoDB 支持行锁，并发更强。

MyISAM 不支持外键和事务。

## 5. 为什么会有最左前缀原则？

我们建立联合索引的时候，往往会有一个顺序，比如联合索引（name，age，email），我们的索引只有一个，如何根据这个联合索引去建立这唯一的索引呢？我们是先按照 name 排序，再按照 age，最后按照 email 来排序的顺序，所以如果我们直接使用 `SELECT * FROM users WHERE age = 12` 的时候，我们直接去寻找年龄为 12 的用户，但是此时我们并没有根据 name 去查找，而是直接根据 age，那么问题来了，如果我们真的去走这个联合索引，我们找到了一个 `age = 12` 的用户，但是这个是唯一的 `age = 12` 的用户吗？很有可能不是，我们根本不可能根据 `age = 12` 这个条件从这个联合索引中去找到所有的 `age = 12` 的用户，所以此时，只能走全表扫描，这就是最左前缀的由来。

​	