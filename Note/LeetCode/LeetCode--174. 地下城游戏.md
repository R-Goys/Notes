[174. 地下城游戏](https://leetcode.cn/problems/dungeon-game/)

> 恶魔们抓住了公主并将她关在了地下城 `dungeon` 的 **右下角** 。地下城是由 `m x n` 个房间组成的二维网格。我们英勇的骑士最初被安置在 **左上角** 的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。
>
> 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。
>
> 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为*负整数*，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 *0*），要么包含增加骑士健康点数的魔法球（若房间里的值为*正整数*，则表示骑士将增加健康点数）。
>
> 为了尽快解救公主，骑士决定每次只 **向右** 或 **向下** 移动一步。
>
> 返回确保骑士能够拯救到公主所需的最低初始健康点数。
>
> **注意：**任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。

---

只在洛谷上和cf上面见过这种有故事的题目，还以为力扣都是那种干巴巴的题干。

题目翻译一下就是要求你选一条路径，使得历史最低的生命值最大。然后返回我们能够通过这条路的初始生命值最低为多少，我们通过逆推的方式，计算消耗的生命最大值，这样的状态转移简单得多。

```go
func calculateMinimumHP(dungeon [][]int) int {
    n, m := len(dungeon), len(dungeon[0])
    f := make([][]int, n + 1)
    for i := 0; i <= n ; i ++ {
        f[i] = make([]int, m + 1)
        for j := 0; j <= m; j++ {
            f[i][j] = 0x3f3f3f3f
        }
    }
    f[n][m - 1], f[n - 1][m] = 1, 1
    for i := n - 1; i >= 0; i-- {
        for j := m - 1; j >= 0; j-- {
            f[i][j] = max(min(f[i + 1][j], f[i][j + 1]) - dungeon[i][j], 1)
        }
    }
    return  f[0][0]
}
```

