[887. 鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop/)

> 给你 `k` 枚相同的鸡蛋，并可以使用一栋从第 `1` 层到第 `n` 层共有 `n` 层楼的建筑。
>
> 已知存在楼层 `f` ，满足 `0 <= f <= n` ，任何从 **高于** `f` 的楼层落下的鸡蛋都会碎，从 `f` 楼层或比它低的楼层落下的鸡蛋都不会破。
>
> 每次操作，你可以取一枚没有碎的鸡蛋并把它从任一楼层 `x` 扔下（满足 `1 <= x <= n`）。如果鸡蛋碎了，你就不能再次使用它。如果某枚鸡蛋扔下后没有摔碎，则可以在之后的操作中 **重复使用** 这枚鸡蛋。
>
> 请你计算并返回要确定 `f` **确切的值** 的 **最小操作次数** 是多少？

---

不会，看了灵神的题解，感觉明白了，来这里粘一下。

这种我觉得应该是最好理解的，i表示可以操作的次数，j表示当前有的鸡蛋数量，f\[i][j]实际上指的就是当前可以判断的最大层数，而这个状态转移方程代表的是什么？

它代表着扔下了一个鸡蛋，碎和没有碎掉的情况，这个就可以拆分成两个子问题，碎掉了，说明第f层在下面，就不需要对上面进行查找了，相当于是求f\[i - 1][j - 1]的最大操作数，这样，我们就可以理解这道题了。

而+1则是代表需要加上当前扔下鸡蛋的那一层。

```go
func superEggDrop(k, n int) int {
    f := make([][]int, n+1)
    f[0] = make([]int, k+1)
    for i := 1; ; i++ {
        f[i] = make([]int, k+1)
        for j := 1; j <= k; j++ {
            f[i][j] = f[i-1][j] + f[i-1][j-1] + 1
        }
        if f[i][k] >= n {
            return i
        }
    }
}
```

