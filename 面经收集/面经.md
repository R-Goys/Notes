## 多级缓存的数据一致性

常见的多级缓存模式为 **本地缓存->分布式缓存->数据库**，对于数据库和分布式缓存的同步策略只需要写后删除即可。而本地缓存需要通过消息队列通知其他节点将这个缓存删除，当然，我们也可以通过 CDC 监听 binlog 来实现 Redis 缓存删除（原因是实现可靠的删除）。

当然 mq 是可能丢消息的，我们也不可能为了消息不丢就做个 outbox，我们还可以给本地缓存指定一个相对比较小的 ttl，防止 mq 消息丢失导致脏数据一直滞留。

即便是这样，也有可能会有不一致的情况，比如一个请求发现本地和分布式缓存都没有数据，然后进入到数据库读取数据，打算回填缓存，此时，另一个请求将新数据写入数据库，然后出发写后删除策略，发给消息队列，此时执行了删除策略，随后，回填了缓存，此时就会产生不一致，所以有一个策略叫做延迟双删策略，通过这个策略可以更大程度保证一致性。

除此之外，还可以使用版本号的策略，通过 mq 广播版本号，让每个节点都同时删除过期的缓存，这样，即便不需要延迟双删也能够防止读到旧数据，当然，对于本地里面没有的 cache，可能意味着我们需要保存多余的数据，我们可以为版本号设置一个合理的过期时间，来保证版本更新之前不会有未执行完的请求，这也是延迟双删所干的事情，但是延迟双删依赖于时间窗口，依旧具有不确定性，但是相对来说已经够可靠了，大多数场景下，短 ttl + 延迟双删都够用了，而版本号能够实现高准确的缓存一致性，但是需要对现有表进行修改，在后期引入会对表有一定侵入性。


## 有栈协程和无栈协程

参考文献：[有栈协程和无栈协程](https://zhuanlan.zhihu.com/p/347445164)

有栈协程就是在用户态去模拟内核干的事情，即在自己的协程栈中去保存自己的寄存器上下文，然后就可以切换到另一个 goroutine 执行，等到需要再次运行这个协程的时候，就从这个协程的栈中恢复。

而无栈协程，意味着每一个协程没有单独的栈去保存他们的上下文，我的理解是编译器将一个异步函数分割成了 N 个阶段，然后在这些函数 await 的时候统一放入工作池中，然后 executor 就可以从工作池中获取这些函数，通过 future 里面记录的 state 来实现调度，本质上就是执行分阶段地去执行函数，比如一个函数可能是这样写的：
```rust
async fn foo() {
    // 阶段 0
    do_a();

    // 阶段 1：等待 X
    let x = X::new().await;
    do_b();

    // 阶段 2：等待 Y
    let y = Y::new().await;
    do_c();
}
```
优化后可能会变成这样
```rust
impl Future for Foo {
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Output> {
        match self.state {
            0 => {
                do A;

                self.state = 1;
                self.x = Some(X::new());
                // 注册 wake
                return Poll::Pending;
            }
            1 => {
                if self.x.as_mut().poll(cx).is_pending() {
                    return Poll::Pending;
                }

                do B;

                self.state = 2;
                self.y = Some(Y::new());
                return Poll::Pending;
            }
            2 => {
                if self.y.as_mut().poll(cx).is_pending() {
                    return Poll::Pending;
                }

                do C;

                return Poll::Ready(());
            }
        }
    }
}
```
由于本质就是一个函数执行（个人感觉无栈协程好抽象），所以局部性原则，以及上下文切换的开销都非常小，这也是无栈协程的优势之一，但是这也意味着无栈协程难以做到真正的抢占式调度，所以我们写代码的时候还得非常注意这一点。

而 Go 中则是由 runtime 在一些 safe point 注入的代码中实现抢占，调度的逻辑，可以说这一点还是比无栈协程好的。而相对来说，无栈协程的上下文切换的开销很小，